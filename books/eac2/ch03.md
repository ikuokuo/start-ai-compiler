# CH03 语法分析器 (Parsers)

- [3.1 简介](#31-简介)
- [3.2 语法的表示](#32-语法的表示)
  - [3.2.1 为什么不使用正则表达式](#321-为什么不使用正则表达式)
  - [3.2.2 上下文无关语法](#322-上下文无关语法)
  - [3.2.3 更复杂的例子](#323-更复杂的例子)
  - [3.2.4 将语义编码到结构中](#324-将语义编码到结构中)
  - [3.2.5 为输入符号串找到推导](#325-为输入符号串找到推导)
- [3.3 自顶向下语法分析](#33-自顶向下语法分析)
  - [3.3.1 为进行自顶向下语法分析而转换语法](#331-为进行自顶向下语法分析而转换语法)
  - [3.3.2 自顶向下的递归下降语法分析器](#332-自顶向下的递归下降语法分析器)
  - [3.3.3 表驱动的LL(1)语法分析器](#333-表驱动的ll1语法分析器)
- [3.4 自底向上语法分析](#34-自底向上语法分析)
  - [3.4.1 LR(1)语法分析算法](#341-lr1语法分析算法)
  - [3.4.2 构建LR(1)表](#342-构建lr1表)
  - [3.4.3 表构造过程中的错误](#343-表构造过程中的错误)
- [3.5 实际问题](#35-实际问题)
  - [3.5.1 出错恢复](#351-出错恢复)
  - [3.5.2 一元运算符](#352-一元运算符)
  - [3.5.3 处理上下文相关的二义性](#353-处理上下文相关的二义性)
  - [3.5.4 左递归与右递归](#354-左递归与右递归)
- [3.6 高级主题](#36-高级主题)
  - [3.6.1 优化语法](#361-优化语法)
  - [3.6.2 减小LR(1)表的规模](#362-减小lr1表的规模)
- [3.7 小结和展望](#37-小结和展望)

## 3.1 简介

语法分析器处理由词法分析器转换生成的程序，从语法分析器的角度来看，输入的程序是一个单词流，其中各个单词都标注了语法范畴（词类）。语法分析器为该程序推导一个语法结构，将各个单词适配到源程序设计语言的语法模型中。

语法分析：给出单词流 s 和语法 G，找到 G 中生成 s 的一个推导。

- 首要职责：识别语法，即确定被编译的程序在程序设计语言的语法模型中是否是一个有效句。

## 3.2 语法的表示

### 3.2.1 为什么不使用正则表达式

RE 缺乏描述语言完整语法的能力。例如，匹配括号优先级。

RE 的固有限制：与 RE 对应的识别器无法进行计数，因为它们是一个有限状态集。原则上，DFA 是无法计数的。

### 3.2.2 上下文无关语法

- 上下文无法语法（Context-free grammar）：对于语言 L，其 CFG 定义了表示 L 中有效语句的字符串的集合。
- 语句（Sentence）：可以从语法规则推导出的一个符号串。

上下文无关语法 G 是一组规则，描述了语句是如何形成的。可以从 G 导出的语句集称为 G 定义的语言，记作 L(G)。

```
SheepNoise → baa SheepNoise
           | baa
```

- 产生式（Production）：CFG 中的每个规则都称为一个产生式。
- 非终结符（Nonterminal symbol）：语法产生式中使用的语法变量。
- 终结符（Terminal symbol）：出现在语法中的单词。
  - 单词包含一个语素及其语法范畴。在语法中，单词通过其语法范畴表示。

用于表示上下文无关文法的传统符号表示法称为 Backus-Naur 范式 (Backus-Naur Form, BNF)。

### 3.2.3 更复杂的例子

括号表达式的语言：

```
Expr → ( Expr )
  | Expr Op name
  | name
Op → +
  | -
  | ×
  | ÷
```

- 语法分析树（Parse tree）：表示推导的图。
- 二义性（Ambiguity）：如果 L(G) 中的某个语句有一个以上最右（或最左）推导，那么语法 G 就是二义性的。

### 3.2.4 将语义编码到结构中

将运算符优先级级别信息编码到语法中：

```
Goal → Expr
Expr → Expr + Term
  | Expr - Term
  | Term
Term → Term x Factor
  | Term ÷ Factor
  | Factor
Factor → ( Expr )
  | num
  | name
```

### 3.2.5 为输入符号串找到推导

输入：单词流；输出：语法树。

构建语法树：

- 自顶向下语法分析器（top-down parser）
- 自底向上语法分析器（bottom-up parser）

## 3.3 自顶向下语法分析

关键点：CFG 的很大一个子集不进行回溯即可完成语法分析。

### 3.3.1 为进行自顶向下语法分析而转换语法

- 具有“神谕”选择能力的自顶向下的语法分析器
- 消除左递归
  - 前向替换（forward substitution）
- 无回溯语法分析
  - FIRST 集合、FOLLOW 集合
- 提取左因子消除回溯

### 3.3.2 自顶向下的递归下降语法分析器

递归下降（recursive descent）

### 3.3.3 表驱动的LL(1)语法分析器

LL(1) 语法分析器由左（Left, L）到右扫描其输入，构建一个最左推导（Leftmost, L），其中仅使用一个前瞻符号（1）。

LL(1) 语法是无法回溯的。

## 3.4 自底向上语法分析

关键点：找到句柄。

### 3.4.1 LR(1)语法分析算法

LR(1) 语法分析器从左（Left, L）到右扫描，反向（Reverse, R）最右推导，一个前瞻符号（1）。

LR(1) 语法分析器使用一种句柄查找自动机，该自动机编码在两个表中，称为 Action 和 Goto。

### 3.4.2 构建LR(1)表

为构建 Action 和 Goto 表，LR(1) 语法分析器生成器会建立句柄识别自动机的一个模型，并使用该模型来填表。这个模型称为 LR(1) 项集的规范簇（canonical collection of sets of LR(1) items），表示了语法分析器的所有可能状态和这些状态之间的转移。

### 3.4.3 表构造过程中的错误

## 3.5 实际问题

### 3.5.1 出错恢复

语法编译器应该在每次编译时找到尽可能多的语法错误。这需要一种机制，使得语法分析器能够从错误中恢复：转移到另一个状态，从而继续进行语法分析。

### 3.5.2 一元运算符

向表达式语法增加一元运算符时需要比较谨慎。

### 3.5.3 处理上下文相关的二义性

使用一个单词表示两种不同语义，可能导致语法二义性。

### 3.5.4 左递归与右递归

决策因素：

- 栈深度
- 结合性

## 3.6 高级主题

### 3.6.1 优化语法

可以降低语法树的高度。

### 3.6.2 减小LR(1)表的规模

- 合并行或列
- 缩减语法
- 表的直接编码
- 使用其他构造算法

## 3.7 小结和展望

如果编译器编写者想要构建一个手工编码的语法分析器，无论其出发点如何，我们都建议他使用自顶向下的递归下降方法。

从现成的语法分析器生成器开始，总比从头开始实现一个语法分析器生成器要好。
