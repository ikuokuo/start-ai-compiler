# 目录

第1章　编译概观 1
1.1　简介 1
1.2　编译器结构 4
1.3　转换概述 7
1.3.1　前端 8
1.3.2　优化器 10
1.3.3　后端 11
1.4　小结和展望 15

第2章　词法分析器 17
2.1　简介 17
2.2　识别单词 18
2.2.1　识别器的形式化 20
2.2.2　识别更复杂的单词 21
2.3　正则表达式 24
2.3.1　符号表示法的形式化 25
2.3.2　示例 26
2.3.3　RE的闭包性质 28
2.4　从正则表达式到词法分析器 30
2.4.1　非确定性有限自动机 30
2.4.2　从正则表达式到NFA：Thompson构造法 33
2.4.3　从NFA到DFA：子集构造法 34
2.4.4　从DFA到最小DFA：Hopcroft 算法 39
2.4.5　将DFA用做识别器 42
2.5　实现词法分析器 43
2.5.1　表驱动词法分析器 44
2.5.2　直接编码的词法分析器 48
2.5.3　手工编码的词法分析器 50
2.5.4　处理关键字 53
2.6　高级主题 54
2.6.1　从DFA到正则表达式 54
2.6.2　DFA最小化的另一种方法： Brzozowski算法 55
2.6.3　无闭包的正则表达式 56
2.7　小结和展望 57

第3章　语法分析器 61
3.1　简介 61
3.2　语法的表示 62
3.2.1　为什么不使用正则表达式 62
3.2.2　上下文无关语法 63
3.2.3　更复杂的例子 66
3.2.4　将语义编码到结构中 69
3.2.5　为输入符号串找到推导 71
3.3　自顶向下语法分析 71
3.3.1　为进行自顶向下语法分析而 转换语法 73
3.3.2　自顶向下的递归下降语法分 析器 81
3.3.3　表驱动的LL(1)语法分析器 83
3.4　自底向上语法分析 87
3.4.1　LR(1)语法分析算法 89
3.4.2　构建LR(1)表 94
3.4.3　表构造过程中的错误 103
3.5　实际问题 106
3.5.1　出错恢复 106
3.5.2　一元运算符 107
3.5.3　处理上下文相关的二义性 108
3.5.4　左递归与右递归 109
3.6　高级主题 111
3.6.1　优化语法 111
3.6.2　减小LR(1)表的规模 113
3.7　小结和展望 116

第4章　上下文相关分析 120
4.1　简介 120
4.2　类型系统简介 122
4.2.1　类型系统的目标 123
4.2.2　类型系统的组件 126
4.3　属性语法框架 134
4.3.1　求值的方法 137
4.3.2　环 138
4.3.3　扩展实例 138
4.3.4　属性语法方法的问题 143
4.4　特设语法制导转换 146
4.4.1　特设语法制导转换的实现 147
4.4.2　例子 148
4.5　高级主题 155
4.5.1　类型推断中更困难的问题 155
4.5.2　改变结合性 157
4.6　小结和展望 158

第5章　中间表示 162
5.1　简介 162
中间表示的分类 163
5.2　图IR 165
5.2.1　与语法相关的树 165
5.2.2　图 168
5.3　线性IR 173
5.3.1　堆栈机代码 173
5.3.2　三地址代码 174
5.3.3　线性代码的表示 175
5.3.4　根据线性代码建立控制流图 176
5.4　将值映射到名字 179
5.4.1　临时值的命名 179
5.4.2　静态单赋值形式 180
5.4.3　内存模型 183
5.5　符号表 186
5.5.1　散列表 187
5.5.2　建立符号表 187
5.5.3　处理嵌套的作用域 188
5.5.4　符号表的许多用途 191
5.5.5　符号表技术的其他用途 193
5.6　小结和展望 193

第6章　过程抽象 198
6.1　简介 198
6.2　过程调用 200
6.3　命名空间 203
6.3.1　类Algol语言的命名空间 203
6.3.2　用于支持类Algol语言的运 行时结构 206
6.3.3　面向对象语言的命名空间 210
6.3.4　支持面向对象语言的运行时 结构 214
6.4　过程之间值的传递 219
6.4.1　传递参数 219
6.4.2　返回值 222
6.4.3　确定可寻址性 223
6.5　标准化链接 227
6.6　高级主题 231
6.6.1　堆的显式管理 231
6.6.2　隐式释放 234
6.7　小结和展望 237

第7章　代码形式 245
7.1　简介 245
7.2　分配存储位置 247
7.2.1　设定运行时数据结构的位置 248
7.2.2　数据区的布局 249
7.2.3　将值保持在寄存器中 252
7.3　算术运算符 253
7.3.1　减少对寄存器的需求 254
7.3.2　访问参数值 255
7.3.3　表达式中的函数调用 257
7.3.4　其他算术运算符 257
7.3.5　混合类型表达式 258
7.3.6　作为运算符的赋值操作 258
7.4　布尔运算符和关系运算符 259
7.4.1　表示 260
7.4.2　对关系操作的硬件支持 262
7.5　数组的存储和访问 265
7.5.1　引用向量元素 266
7.5.2　数组存储布局 267
7.5.3　引用数组元素 268
7.5.4　范围检查 272
7.6　字符串 273
7.6.1　字符串表示 273
7.6.2　字符串赋值 274
7.6.3　字符串连接 275
7.6.4　字符串长度 276
7.7　结构引用 277
7.7.1　理解结构布局 277
7.7.2　结构数组 278
7.7.3　联合和运行时标记 278
7.7.4　指针和匿名值 279
7.8　控制流结构 281
7.8.1　条件执行 281
7.8.2　循环和迭代 283
7.8.3　case语句 286
7.9　过程调用 289
7.9.1　实参求值 290
7.9.2　保存和恢复寄存器 291
7.10　小结和展望 292

第8章　优化简介 298
8.1　简介 298
8.2　背景 299
8.2.1　例子 300
8.2.2　对优化的考虑 303
8.2.3　优化的时机 305
8.3　优化的范围 306
8.4　局部优化 308
8.4.1　局部值编号 309
8.4.2　树高平衡 314
8.5　区域优化 321
8.5.1　超局部值编号 321
8.5.2　循环展开 324
8.6　全局优化 327
8.6.1　利用活动信息查找未初始化 变量 328
8.6.2　全局代码置放 331
8.7　过程间优化 336
8.7.1　内联替换 337
8.7.2　过程置放 340
8.7.3　针对过程间优化的编译器组织结构 344
8.8　小结和展望 345

第9章　数据流分析 350
9.1　简介 350
9.2　迭代数据流分析 351
9.2.1　支配性 352
9.2.2　活动变量分析 355
9.2.3　数据流分析的局限性 359
9.2.4　其他数据流问题 361
9.3　静态单赋值形式 365
9.3.1　构造静态单赋值形式的简单 方法 366
9.3.2　支配边界 366
9.3.3　放置 函数 369
9.3.4　重命名 372
9.3.5　从静态单赋值形式到其他形式的转换 376
9.3.6　使用静态单赋值形式 379
9.4　过程间分析 383
9.4.1　构建调用图 383
9.4.2　过程间常量传播 385
9.5　高级主题 388
9.5.1　结构性数据流算法和可归 约性 388
9.5.2　加速计算支配性的迭代框架 算法的执行 391
9.6　小结和展望 393

第10章　标量优化 398
10.1　简介 398
10.2　消除无用和不可达代码 401
10.2.1　消除无用代码 402
10.2.2　消除无用控制流 404
10.2.3　消除不可达代码 406
10.3　代码移动 407
10.3.1　缓式代码移动 407
10.3.2　代码提升 413
10.4　特化 414
10.4.1　尾调用优化 415
10.4.2　叶调用优化 416
10.4.3　参数提升 416
10.5　冗余消除 417
10.5.1　值相同与名字相同 417
10.5.2　基于支配者的值编号算法 418
10.6　为其他变换制造时机 421
10.6.1　超级块复制 421
10.6.2　过程复制 422
10.6.3　循环外提 423
10.6.4　重命名 423
10.7　高级主题 425
10.7.1　合并优化 425
10.7.2　强度削减 429
10.7.3　选择一种优化序列 437
10.8　小结和展望 438

第11章　指令选择 441
11.1　简介 441
11.2　代码生成 443
11.3　扩展简单的树遍历方案 445
11.4　通过树模式匹配进行指令选择 450
11.4.1　重写规则 451
11.4.2　找到平铺方案 454
11.4.3　工具 457
11.5　通过窥孔优化进行指令选择 458
11.5.1　窥孔优化 458
11.5.2　窥孔变换程序 463
11.6　高级主题 465
11.6.1　学习窥孔模式 465
11.6.2　生成指令序列 466
11.7　小结和展望 467

第12章　指令调度 470
12.1　简介 470
12.2　指令调度问题 473
12.2.1　度量调度质量的其他方式 477
12.2.2　是什么使调度这样难 478
12.3　局部表调度 478
12.3.1　算法 478
12.3.2　调度具有可变延迟的操作 481
12.3.3　扩展算法 481
12.3.4　在表调度算法中打破平局 481
12.3.5　前向表调度与后向表调度 482
12.3.6　提高表调度的效率 484
12.4　区域性调度 485
12.4.1　调度扩展基本程序块 486
12.4.2　跟踪调度 487
12.4.3　通过复制构建适当的上下文 环境 488
12.5　高级主题 489
12.5.1　软件流水线的策略 490
12.5.2　用于实现软件流水线的 算法 492
12.6　小结和展望 495

第13章　寄存器分配 499
13.1　简介 499
13.2　背景问题 500
13.2.1　内存与寄存器 500
13.2.2　分配与指派 501
13.2.3　寄存器类别 502
13.3　局部寄存器分配和指派 502
13.3.1　自顶向下的局部寄存器 分配 503
13.3.2　自底向上的局部寄存器 分配 504
13.3.3　超越单个程序块 506
13.4　全局寄存器分配和指派 509
13.4.1　找到全局活动范围 511
13.4.2　估算全局逐出代价 512
13.4.3　冲突和冲突图 513
13.4.4　自顶向下着色 515
13.4.5　自底向上着色 517
13.4.6　合并副本以减小度数 518
13.4.7　比较自顶向下和自底向上 全局分配器 520
13.4.8　将机器的约束条件编码到 冲突图中 521
13.5　高级主题 523
13.5.1　图着色寄存器分配方法的 变体 523
13.5.2　静态单赋值形式上的全局寄 存器分配 525
13.6　小结和展望 526

附录A　ILOC 531
附录B　数据结构 540
参考文献　559
索引　574
