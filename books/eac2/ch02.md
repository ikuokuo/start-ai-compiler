# CH02 词法分析器 (Scanners)

- [2.1 简介](#21-简介)
- [2.2 识别单词](#22-识别单词)
  - [2.2.1 识别器的形式化](#221-识别器的形式化)
  - [2.2.2 识别更复杂的单词](#222-识别更复杂的单词)
- [2.3 正则表达式](#23-正则表达式)
  - [2.3.1 符号表示法的形式化](#231-符号表示法的形式化)
  - [2.3.2 示例](#232-示例)
  - [2.3.3 RE的闭包性质](#233-re的闭包性质)
- [2.4 从正则表达式到词法分析器](#24-从正则表达式到词法分析器)
  - [2.4.1 非确定性有限自动机](#241-非确定性有限自动机)
  - [2.4.2 从正则表达式到NFA：Thompson构造法](#242-从正则表达式到nfathompson构造法)
  - [2.4.3 从NFA到DFA：子集构造法](#243-从nfa到dfa子集构造法)
  - [2.4.4 从DFA到最小DFA：Hopcroft算法](#244-从dfa到最小dfahopcroft算法)
  - [2.4.5 将DFA用做识别器](#245-将dfa用做识别器)
- [2.5 实现词法分析器](#25-实现词法分析器)
  - [2.5.1 表驱动词法分析器](#251-表驱动词法分析器)
  - [2.5.2 直接编码的词法分析器](#252-直接编码的词法分析器)
  - [2.5.3 手工编码的词法分析器](#253-手工编码的词法分析器)
  - [2.5.4 处理关键字](#254-处理关键字)
- [2.6 高级主题](#26-高级主题)
  - [2.6.1 从DFA到正则表达式](#261-从dfa到正则表达式)
  - [2.6.2 DFA最小化的另一种方法：Brzozowski算法](#262-dfa最小化的另一种方法brzozowski算法)
  - [2.6.3 无闭包的正则表达式](#263-无闭包的正则表达式)
- [2.7 小结和展望](#27-小结和展望)

## 2.1 简介

### 概述

词法分析器读取由字符组成的输入流，并产生包含单词的输出流，每个单词都标记了其语法范畴，等效于英文单词的词类。

- 语法范畴：根据单词的语法用途对单词进行的分类。
- 微语法：语言的词法结构。
- 关键词：为特定语法目的而保留的单词，不能用作标识符。

## 2.2 识别单词

### 2.2.1 识别器的形式化

转移图（transition diagram）可以看作是形式化的数学对象，称为有限自动机（finite automata），它定义了识别器的规格。

- 有限自动机（finite automaton）：识别器的一种形式化方法，包含一个有限状态集、一个字母表、一个转移函数、一个起始状态和一个或多个接受状态。

形式上，有限自动机（FA）是一个五元组 (S, Σ, δ, s0, SA)，其中各分量的含义如下所示：

- S: 有限状态集
- Σ: 有限字母表
- δ(s, c): 转移函数
- s0 ∈ S: 起始状态
- SA ⊆ S: 接受状态集

### 2.2.2 识别更复杂的单词

- 词素：对 FA 识别的一个单词来说，即单词对应的实际文本。

小的单词集合很容易编码为无环的转移图。而无限集，如整数或标识符的集合，则需要有环的转移图。

## 2.3 正则表达式

对于任一 FA，我们还可以使用一种称为正则表达式（Regular Expression, RE）的符号表示法来描述其语言。

### 2.3.1 符号表示法的形式化

一个 RE 由三个基本操作组成：选择、连接、闭包。

为了消除二义性，括号具有最高优先级，接下来顺次为闭包、连接、选择。

### 2.3.2 示例

FA 的开销与输入长度成正比，和生成 FA 的 RE 长度或复杂性无关。

### 2.3.3 RE的闭包性质

- 正则语言：任何可以用正则表达式定义的语言都称为正则语言。

正则表达式在许多操作下是封闭的，即如果我们将操作应用到一个 RE 或一组 RE，其结果仍然是 RE。

## 2.4 从正则表达式到词法分析器

### 2.4.1 非确定性有限自动机

-  转移：针对空串输入  进行的转移，不会改变输入流中的读写位置。

利用  转移合并两个 FA，可能会使我们关于 FA 工作方式的模型复杂化。

- NFA: 非确定性 FA (nondeterministic finite automaton)
  - 允许在空串输入  上进行转移的 FA，其状态对同一字符输入可能有多种转移。
- DFA: 确定性 FA (deterministic finite automaton)
  - 转移函数为单值的 FA 称为 DFA。DFA 不允许  转移。

为澄清 NFA 的语义，历史上，已经给出了两种不同的模型：

- 每次 NFA 必须进行非确定性选择时，如果有使得输入字符串转向接受状态的存在，则采用这样的转移。
- 每次 NFA 必须进行非确定性选择时，NFA 都克隆自身，以追踪每个可能的转移。

NFA 与 DFA 在表达力上是等价的。任何 DFA 都是某个 NFA 的一个特例。

### 2.4.2 从正则表达式到NFA：Thompson构造法

Thompson构造法：它有一个模板，用于构建对应于单字母 RE 的 NFA，还有一种 NFA 上的转换，模拟了连接、选择和闭包等各个基本 RE 运算符的效果。

这个构造法从为输入 RE 中每个字符构建简单的 NFA 开始。接下来，它按照优先级和括号规定的顺序，对简单 NFA 的集合应用选择、连接和闭包等转换。

### 2.4.3 从NFA到DFA：子集构造法

子集构造法以 NFA(N, Σ, δN, n0, NA) 为输入，生成一个 DFA(D, Σ, δD, d0, DA)。

子集构造法是不动点计算的一个例子，这是一种特定风格的计算，经常在计算机科学出现。这种计算的特点在于，对取自某个结构已知的域中的集族，重复应用一个单调函数。当计算到达某个状态时，如果进一步的迭代只能得出已有的结果，那么计算将终止，这相当于连续的迭代在空间中遇到了一个“不动点”。在编译器构建过程中，不动点计算扮演了重要的角色，且会重复出现。

### 2.4.4 从DFA到最小DFA：Hopcroft算法

- 集合划分：集合 S 的一个划分也是一个集合，该集合的元素是 S 的非空不相交子集，且该集合中各个元素的并集刚好是 S。

### 2.4.5 将DFA用做识别器

## 2.5 实现词法分析器

将 DFA 转换为可执行代码的三种三种实现策略：表驱动词法分析器、直接编码的词法分析器和手工编码的词法分析器。

三种实现策略在运行时成本的细节上有所不同。但它们都具有同样的渐近复杂度，即处理每个字符的成本为常数，外加回滚的成本。

这些策略的不同之处在于，它们对 DFA 的转移结构进行建模的方式和模拟 DFA 操作的方式。这些差别进而又导致不同的运行时成本。

### 2.5.1 表驱动词法分析器

- 避免过度回滚
  - 最长适配词法分析器（maximal munch scanner）
- 生成转移表和分类器表
- 改变语言

### 2.5.2 直接编码的词法分析器

直接编码的词法分析器降低了计算 DFA 转移的成本，它将原本显示表示的 DFA 状态和转移图替换为隐式表示方法。隐式表示简化了原本两步的查表计算过程。

- 查表的开销
- 替换表驱动词法分析器的 while 循环
- 归类字符

### 2.5.3 手工编码的词法分析器

直接编码的词法分析器减少模拟 DFA 所需的开销，而手工编码的词法分析器可以减少词法分析器和系统其余组件之间的接口的开销。

- 输入流的缓冲
  - 双缓冲：使用两个输入缓冲区，以取模方式提供有限回滚机制的方案
- 生成词素

### 2.5.4 处理关键字

利用合理的散列表，每次查找的预期代价应该是常数量级。实际上，这个方案已经是完美散列（perfect hashing）的一个经典应用。

如果使用词法分析器生成器来构建识别器，那么在 DFA 中识别关键字所增加的复杂性是由工具处理的。此时增加的状态会多消耗内存，但不会导致编译时间延长。使用 DFA 机制识别关键字，避免了对每个标识符都进行查表。这也避免了实现关键字表及其支持函数的开销。在大多数情况下，与使用单独的查找表相比，将关键字识别功能集成到 DFA 中更有意义。

## 2.6 高级主题

### 2.6.1 从DFA到正则表达式

RE 和 DFA 是等价的，可从 DFA 导出对应的 RE。

### 2.6.2 DFA最小化的另一种方法：Brzozowski算法

Brzozowski 算法是一种 DFA 最小化算法，可以直接基于 NFA 构建最小的 DFA。

给定 NFA n，等价的最小 DFA 就是下述表达式：

`reachable( subset( reverse( reachable( subset( reverse(n))) )))`

### 2.6.3 无闭包的正则表达式

- 许多（字符串）模式识别问题能够用无闭包 RE 描述
- 可以用一种特别有效的方式来构建对应于无闭包 RE 的 DFA

## 2.7 小结和展望

正则表达式和有限自动机的理论已经开发出一些技术，使得识别正则语言的时间和输入流长度成正比。从 RE 自动推导 DFA 的技术，以及 DFA 最小化的技术，确保能够构建一些健壮的工具，并通过这些工具来生成基于 DFA 的识别器。
