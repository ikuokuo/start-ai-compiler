# CH07 代码形式 (Code Shape)

- [7.1 简介](#71-简介)
- [7.2 分配存储位置](#72-分配存储位置)
  - [7.2.1 设定运行时数据结构的位置](#721-设定运行时数据结构的位置)
  - [7.2.2 数据区的布局](#722-数据区的布局)
  - [7.2.3 将值保持在寄存器中](#723-将值保持在寄存器中)
- [7.3 算术运算符](#73-算术运算符)
  - [7.3.1 减少对寄存器的需求](#731-减少对寄存器的需求)
  - [7.3.2 访问参数值](#732-访问参数值)
  - [7.3.3 表达式中的函数调用](#733-表达式中的函数调用)
  - [7.3.4 其他算术运算符](#734-其他算术运算符)
  - [7.3.5 混合类型表达式](#735-混合类型表达式)
  - [7.3.6 作为运算符的赋值操作](#736-作为运算符的赋值操作)
- [7.4 布尔运算符和关系运算符](#74-布尔运算符和关系运算符)
  - [7.4.1 表示](#741-表示)
  - [7.4.2 对关系操作的硬件支持](#742-对关系操作的硬件支持)
- [7.5 数组的存储和访问](#75-数组的存储和访问)
  - [7.5.1 引用向量元素](#751-引用向量元素)
  - [7.5.2 数组存储布局](#752-数组存储布局)
  - [7.5.3 引用数组元素](#753-引用数组元素)
  - [7.5.4 范围检查](#754-范围检查)
- [7.6 字符串](#76-字符串)
  - [7.6.1 字符串表示](#761-字符串表示)
  - [7.6.2 字符串赋值](#762-字符串赋值)
  - [7.6.3 字符串连接](#763-字符串连接)
  - [7.6.4 字符串长度](#764-字符串长度)
- [7.7 结构引用](#77-结构引用)
  - [7.7.1 理解结构布局](#771-理解结构布局)
  - [7.7.2 结构数组](#772-结构数组)
  - [7.7.3 联合和运行时标记](#773-联合和运行时标记)
  - [7.7.4 指针和匿名值](#774-指针和匿名值)
- [7.8 控制流结构](#78-控制流结构)
  - [7.8.1 条件执行](#781-条件执行)
  - [7.8.2 循环和迭代](#782-循环和迭代)
  - [7.8.3 case语句](#783-case语句)
- [7.9 过程调用](#79-过程调用)
  - [7.9.1 实参求值](#791-实参求值)
  - [7.9.2 保存和恢复寄存器](#792-保存和恢复寄存器)
- [7.10 小结和展望](#710-小结和展望)

## 7.1 简介

“代码形式”的概念包含了编译器编写者为在 IR 和汇编代码中表示计算过程而作出的所有相关决策。细心关注代码形式既可以简化分析和改进代码的任务，也可以提高编译器生成的最终代码的质量。

## 7.2 分配存储位置

作为转换过程的一部分，编译器必须为代码产生的各个值分别分配一个存储位置。编译器必须理解值的类型、长度、可见性和生命周期。编译器必须考虑到内存的运行时布局、源语言对数据区和数据结构布局的约束、目标处理器对数据位置或使用的约束。编译器通过定义和遵循一组约定来解决这些问题。

编译选项也可能影响到值的放置，例如，为与调试器协作而编译的代码，应该保留所有调试器可以引用的名字，通常是有名字的变量。

编译器还必须对各个值分别作出决定，是将其保存在寄存器中还是保存在内存中。

### 7.2.1 设定运行时数据结构的位置

为分配存储，编译器必须理解全系统范围内对内存分配和使用的约定。编译器、操作系统和处理器协作，以确保多个程序能够以交错的方式（时间片）安全地运行。因而，有关程序地址空间布局、操控和管理的许多决策超出了编译器编写者的权责范围。但这些决策对编译器产生的代码有着巨大的影响。因而，编译器编写者必须充分地理解这些问题。

典型逻辑地址空间布局：

```
低端：代码 → 静态/全局数据 → 堆 → 空闲内存 → 栈
```

堆和栈应该置于开放空间的两端，彼此相对增长。

### 7.2.2 数据区的布局

编译器将具有同样生命周期和可见性的值群集起来存储；编译器为此创建了若干不同的数据区。这些数据区的放置取决于有关值的生命周期和可见性的语言规则。

高速缓存：基于编译器来改进内存性能的工作专注于提高缓存命中（cache hit）相对于缓存失效（cache miss）的比率，即命中率（hit ratio）。

- 分配偏移量
  - 目标机器的指令集（ISA）限制了数据项在内存中的放置。
- 相对偏移量和高速缓存性能

### 7.2.3 将值保持在寄存器中

一种简单的方法来为值分配虚拟寄存器：每个值都得到一个其自身的虚拟寄存器，以不同的下标区分。这种规范将一个最大的值集提供给后续的分析和优化阶段。当然，这种做法实际上可能会使用过多的名字。但这种方案有三大优点：

- 它很简单
- 它可以改进分析和优化的结果
- 它防止编译器编写者在优化阶段之前将特定于处理器的约束集成到编译器代码中，从而增强了编译器的可移植性

编译器可以保持在寄存器中的值称为无歧义值；有多个名字的值称为歧义值。

- 无歧义值（Unambiguous value）：只能一个名字访问的值是无歧义的。
- 歧义值（Ambiguous value）：可以用多个名字访问的值是有歧义的。

一般来说，编译器将歧义值保持在寄存器中的时间，将在另一个歧义值的定义或使用之前结束。

## 7.3 算术运算符

### 7.3.1 减少对寄存器的需求

一般来说，在每个结点处，编译器只要首先对寄存器使用量最大的子树求值，就能够最小化寄存器的使用量。

### 7.3.2 访问参数值

### 7.3.3 表达式中的函数调用

### 7.3.4 其他算术运算符

### 7.3.5 混合类型表达式

### 7.3.6 作为运算符的赋值操作

## 7.4 布尔运算符和关系运算符

因为大多程序设计语言的关系运算符都产生布尔值结果，我们将布尔运算符和关系运算符一同处理。

### 7.4.1 表示

数值编码：当程序将布尔运算或关系操作的结果保存到一个变量中时，编译器必须确保该值有一个具体的表示。编译器编写者必须为 true 和 false 分配数值，使之能够于硬件操作（如 and, or, not）协同工作。通常，使用 0 表示 false，使用 1 或各比特位全 1 的一个字（~false）来表示 true。

位置编码：编译器用代码中的位置来编码该值。

### 7.4.2 对关系操作的硬件支持

目标机指令集的具体底层细节会强烈地影响到表示关系时可供选择地方案。具体而言，编译器编写者必须注意对条件码、比较操作、条件复制操作地处理，因为它们对各种表示地相对成本有着重要影响。

支持关系表达式的方案：

- 直接条件码
- 条件复制
- 布尔值比较
- 谓词执行

## 7.5 数组的存储和访问

定位并引用数组元素所需的代码，其复杂程度令人惊讶。

### 7.5.1 引用向量元素

而地址和偏移量的加法似乎是不可避免的，或许这也能解释为什么大多数处理器都包含一种基地址/偏移量寻址的方式，该寻址方式用于访问基地址+偏移量指定的内存位置。

### 7.5.2 数组存储布局

访问多维数组的一个元素需要更多的工作。

布局：

- 行主序（row-major order）
- 列主序（column major order）
- 间接向量（indirection vectors）

### 7.5.3 引用数组元素

- 行主序
- 间接向量
- 访问值为数组的参数

### 7.5.4 范围检查

## 7.6 字符串

### 7.6.1 字符串表示

编译器编写者必须为字符串选择一种表示；该表示的细节对字符串操作的代价有着巨大影响。

- 零结尾
- 显示长度字段

### 7.6.2 字符串赋值

### 7.6.3 字符串连接

连接不过是一个或多个赋值操作序列的简写。

### 7.6.4 字符串长度

## 7.7 结构引用

结构和指针的引入，给编译器带来了两个不同的问题：匿名值和结构布局。

### 7.7.1 理解结构布局

### 7.7.2 结构数组

### 7.7.3 联合和运行时标记

### 7.7.4 指针和匿名值

通过分析来消除指针引用和数组引用的二义性，是对程序性能的各种潜在改进的主要来源。

对于密集使用指针的程序，编译器可以进行过程间数据流分析，以便其找到每个指针可能指向的对象的集合。

对于密集使用数组的程序，编译器可以使用数据相关性分析来了解数组引用的模式。

## 7.8 控制流结构

### 7.8.1 条件执行

实现 if-then-else 时，如果要在分支和谓词之间作出选择，需要谨慎小心，应该考虑如下几个问题。

- 预期执行频度
- 代码数量的不均衡
- 条件分支结构内部的控制流

### 7.8.2 循环和迭代

- for 循环
- FORTRAN 的 do 循环
- while 循环
- until 循环
- 将迭代表示为尾递归
- break 语句

### 7.8.3 case语句

定位目标 case 子句的查找策略：

- 线性查找
- 直接计算地址
- 二分查找

## 7.9 过程调用

### 7.9.1 实参求值

编译器应该使用一致的顺序进行求值。

### 7.9.2 保存和恢复寄存器

- 使用多寄存器内存操作
- 使用库例程
- 合并责任

## 7.10 小结和展望
