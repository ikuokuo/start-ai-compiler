# CH13 寄存器分配 (Register Allocation)

- [13.1 简介](#131-简介)
- [13.2 背景问题](#132-背景问题)
  - [13.2.1 内存与寄存器](#1321-内存与寄存器)
  - [13.2.2 分配与指派](#1322-分配与指派)
  - [13.2.3 寄存器类别](#1323-寄存器类别)
- [13.3 局部寄存器分配和指派](#133-局部寄存器分配和指派)
  - [13.3.1 自顶向下的局部寄存器分配](#1331-自顶向下的局部寄存器分配)
  - [13.3.2 自底向上的局部寄存器分配](#1332-自底向上的局部寄存器分配)
  - [13.3.3 超越单个程序块](#1333-超越单个程序块)
- [13.4 全局寄存器分配和指派](#134-全局寄存器分配和指派)
  - [13.4.1 找到全局活动范围](#1341-找到全局活动范围)
  - [13.4.2 估算全局逐出代价](#1342-估算全局逐出代价)
  - [13.4.3 冲突和冲突图](#1343-冲突和冲突图)
  - [13.4.4 自顶向下着色](#1344-自顶向下着色)
  - [13.4.5 自底向上着色](#1345-自底向上着色)
  - [13.4.6 合并副本以减小度数](#1346-合并副本以减小度数)
  - [13.4.7 比较自顶向下和自底向上全局分配器](#1347-比较自顶向下和自底向上全局分配器)
  - [13.4.8 将机器的约束条件编码到冲突图中](#1348-将机器的约束条件编码到冲突图中)
- [13.5 高级主题](#135-高级主题)
  - [13.5.1 图着色寄存器分配方法的变体](#1351-图着色寄存器分配方法的变体)
  - [13.5.2 静态单赋值形式上的全局寄存器分配](#1352-静态单赋值形式上的全局寄存器分配)
- [13.6 小结和展望](#136-小结和展望)

## 13.1 简介

寄存器是内存层次机构中最快速的位置。通常，它们是大多数操作能够直接访问的唯一内存位置。

寄存器分配的目标是，有效利用目标机的寄存器集合，并使得代码必须执行的 load 和 store 指令数目最小化。

- 逐出代码（spill code）：寄存器分配器插入的 load 和 store 指令。

## 13.2 背景问题

### 13.2.1 内存与寄存器

### 13.2.2 分配与指派

- 寄存器分配（Register Allocation）将一个无限的名字空间映射到目标机的寄存器集合上。
- 寄存器指派（Register Assignment）将一个已分配的名字集合映射到目标机的物理寄存器。

区间图（interval graph）表示多个区间在实数轴上的重叠。

### 13.2.3 寄存器类别

通用寄存器、浮点寄存器

## 13.3 局部寄存器分配和指派

局部分配（local allocation）器运行在单个基本程序块上。

### 13.3.1 自顶向下的局部寄存器分配

自顶向下的局部分配器的工作机制基于一种简单的原则：使用得最多得值应该驻留在寄存器中。

### 13.3.2 自底向上的局部寄存器分配

自底向上的局部分配器背后得关键思想是：按逐个操作的方式来仔细考察值定义和使用的细节。

### 13.3.3 超越单个程序块

- 活动性和活动范围
- 程序块边界处的复杂情况

## 13.4 全局寄存器分配和指派

在两个基本方面，全局寄存器分配不同于局部寄存器分配。

- 全局活动范围的结构比局部活动范围更为复杂
- 在全局活动范围内部，不同引用的执行次数可能是不同的

为作出这些决策，许多编译器使用类似于图着色的方法进行寄存器分配。

子问题：

- 发现活动范围
- 估算逐出代价
- 建立冲突图

### 13.4.1 找到全局活动范围

编译器可以将全局活动范围表示为一个或多个静态单赋值形式名的集合。

### 13.4.2 估算全局逐出代价

逐出每个值得代价有 3 个部分：地址计算、内存操作和估算得执行频度。

- 统计执行频度
- 负的逐出代价
- 无限的逐出代价

### 13.4.3 冲突和冲突图

全局寄存器分配器必须模拟的基本效应，是各个值对处理器寄存器集合中空间的竞争。

- 建立冲突图
- 建立分配器
  - 分配器需要一种高效的技术以找到 k 着色方案
  - 分配器需要一种策略来处理下述情况：对某个特定的活动范围没有颜色可用

### 13.4.4 自顶向下着色

自顶向下的图着色全局寄存器分配器，会利用底层信息为各个活动范围指派颜色，而利用高层信息来选择对活动范围着色的顺序。

- 处理逐出
- 拆分活动范围

### 13.4.5 自底向上着色

与自顶向下的全局分配器相比，自底向上的图着色寄存器分配器使用了许多与前者相同的机制。这种分配器会发现活动范围、建立冲突图、试图对图着色，并在必要时生成逐出代码。

自顶向下和自底向上分配器之间的主要区别在于，二者用于对活动范围排序以确定着色顺序的机制不同。自顶向下的分配器使用高层信息来选择一种着色顺序，而自底向上的分配器则根据有关冲突图的详细结构性知识来计算一种顺序。这种分配器会在活动范围的集合上构造一种线性顺序，并按该顺序来一一考虑各个活动范围并指派颜色。

- 可行性的由来

### 13.4.6 合并副本以减小度数

### 13.4.7 比较自顶向下和自底向上全局分配器

### 13.4.8 将机器的约束条件编码到冲突图中

- 多寄存器值
- 特定的寄存器安排

## 13.5 高级主题

### 13.5.1 图着色寄存器分配方法的变体

- 不精确的冲突图
- 将冲突图分解为若干部分
- 保守合并（conservative coalescing）
  - 有偏着色（biased coloring）
- 逐出部分活动范围
- 活动范围拆分
  - 零代价拆分（zero-cost splitting）、被动拆分（passive splitting）
- 再次物化（rematerialization）
- 歧义值

### 13.5.2 静态单赋值形式上的全局寄存器分配

如果编译器根据静态单赋值形式名而不是活动范围建立冲突图，那么结果是弦图（chordal graph）。弦图的 k 着色问题可以在 O(|V|+|E|) 时间内解决。

## 13.6 小结和展望
