# CH08 优化简介 (Introduction to Optimization)

- [8.1 简介](#81-简介)
- [8.2 背景](#82-背景)
  - [8.2.1 例子](#821-例子)
  - [8.2.2 对优化的考虑](#822-对优化的考虑)
  - [8.2.3 优化的时机](#823-优化的时机)
- [8.3 优化的范围](#83-优化的范围)
- [8.4 局部优化](#84-局部优化)
  - [8.4.1 局部值编号](#841-局部值编号)
  - [8.4.2 树高平衡](#842-树高平衡)
- [8.5 区域优化](#85-区域优化)
  - [8.5.1 超局部值编号](#851-超局部值编号)
  - [8.5.2 循环展开](#852-循环展开)
- [8.6 全局优化](#86-全局优化)
  - [8.6.1 利用活动信息查找未初始化变量](#861-利用活动信息查找未初始化变量)
  - [8.6.2 全局代码置放](#862-全局代码置放)
- [8.7 过程间优化](#87-过程间优化)
  - [8.7.1 内联替换](#871-内联替换)
  - [8.7.2 过程置放](#872-过程置放)
  - [8.7.3 针对过程间优化的编译器组织结构](#873-针对过程间优化的编译器组织结构)
- [8.8 小结和展望](#88-小结和展望)

## 8.1 简介

优化器是编译器的中间部分，它的任务是转换前端产生的 IR 程序，以提高后端生成的代码的质量。

代码优化的目标是在编译时发现有关程序运行时行为的信息，利用该信息来改进编译器生成的代码。

优化机会的来源：

- 低效性的主要来源是对源语言抽象的实现
- 另一个重要来源在于目标机

## 8.2 背景

调试编译器：强调的是编译的速度，其代价是代码的质量。

优化编译器：专注于改进可执行代码的运行时间，其代价是编译花费的时间。

随着 RISC 处理器进入市场，提高运行时性能的更多负担落在了编译器的头上。为提高性能，处理器架构师转而采用一些需要编译器提供更多支持的特性。这包括分支指令之后的延迟槽、非阻塞内存操作、流水线使用的增多以及功能单元数目的增加等。

优化使前端与性能问题进一步隔离开来。在一定程度上，这简化了前端生成 IR 的任务。同时，优化也改变了后端处理的代码。现代优化器假定后端会处理资源分配的问题，因而，优化器通常是针对有无限寄存器、内存和功能单元的理想机器进行优化。这进而对编译器后端使用的技术施加了更多的压力。

### 8.2.1 例子

- 改进数组地址计算
- 改进 LINPACK 中的嵌套循环

### 8.2.2 对优化的考虑

- 安全性
- 可获利性
- 风险

### 8.2.3 优化的时机

- 减少抽象的开销
- 利用特例
- 将代码匹配到系统资源

## 8.3 优化的范围

- 局部方法
- 区域性方法
- 全局方法
  - 也称为过程内方法
- 过程间方法
  - 有时称为全程序方法

## 8.4 局部优化

作用于局部范围即单个基本程序块上的优化。

### 8.4.1 局部值编号

用于查找基本程序块中的冗余表达式，通过重用此前计算过的值来替换冗余的求值。

- 算法：LVN (Local Value Numbering)
- 扩展 LVN 算法
  - 交换运算、常量合并、代数恒等式
- 命名的作用
- 间接赋值的影响

### 8.4.2 树高平衡

用于重新组织表达式树，以揭示更多指令层次的并行性。

- 找到候选树
- 重构程序块使之具有平衡的形式
- 例子

## 8.5 区域优化

作用于包括多个基本程序块的代码区域，但通常不会延伸到整个过程。

从局部优化转移到区域优化，主要的复杂之处在于需要处理控制流的多种可能性。

### 8.5.1 超局部值编号

为改进 LVN 算法的结果，编译器可以将其范围从单个基本程序块延伸到一个扩展基本程序块（Extended Basic Block, EBB）。

SVN (Superlocal Value Numbering)

### 8.5.2 循环展开

外层循环展开和后续的内层循环融合的组合通常称为展开-轧挤（unroll-and-jam）。

- 提高和降低的来源

## 8.6 全局优化

### 8.6.1 利用活动信息查找未初始化变量

数据流分析

- 定义数据流问题
- 解决这个数据流问题
  - 构建 CFG
  - 收集初始信息
  - 求解方程式
- 查找未初始化的变量
- 对活动变量的其他使用

### 8.6.2 全局代码置放

- 获取剖析数据
- 以链的形式在 CFG 中构建热路径
- 进行代码布局
- 最后一个例子

## 8.7 过程间优化

过程调用形成了软件系统中的边界。将一个程序划分为多个过程，对于编译器生成高效代码的能力具有正反两方面的影响。

正面：限制了编译器在任一时刻需要考虑的代码数量。这使得编译时数据结构保持在比较小的尺寸上，同时通过对问题规模的约束又限制了各种编译时算法的代价。

负面：

- 限制了编译器理解调用过程内部行为的能力。
- 对每个调用者来说，调用者必定执行一个调用前代码序列和一个返回后代码序列，同时被调用者中必定要执行一个起始代码序列和一个收尾代码序列。这些代码序列实现的操作是要花费时间的。这些代码序列之间的转移需要跳转。

### 8.7.1 内联替换

内联替换（Inline Substitution）是一种变换，它将一个调用位置替换为被调用者过程体的一个副本，并重写代码以反映参数的绑定。

- 变换
- 决策过程
  - 被调用者规模
  - 调用者规模
  - 动态调用计数
  - 常数值实参
  - 静态调用计数
  - 参数计数
  - 过程中的调用
  - 循环嵌套的深度
  - 占执行时间的比例

### 8.7.2 过程置放

在可执行映像内部重排各个过程。

### 8.7.3 针对过程间优化的编译器组织结构

建立一个跨两个或更多过程进行分析和优化的编译器，这从根本上改变了编译器与其所生成代码之间的关系。

能够进行全程序或过程间优化的几种不同编译器结构：

- 扩大编译单元
- 集成开发环境
- 链接时优化
  - 动态链接会限制链接时优化的机会

## 8.8 小结和展望
