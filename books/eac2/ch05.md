# CH05 中间表示 (Intermediate Representations)

- [5.1 简介](#51-简介)
  - [5.1.1 中间表示的分类](#511-中间表示的分类)
- [5.2 图IR](#52-图ir)
  - [5.2.1 与语法相关的树](#521-与语法相关的树)
  - [5.2.2 图](#522-图)
- [5.3 线性IR](#53-线性ir)
  - [5.3.1 堆栈机代码](#531-堆栈机代码)
  - [5.3.2 三地址代码](#532-三地址代码)
  - [5.3.3 线性代码的表示](#533-线性代码的表示)
  - [5.3.4 根据线性代码建立控制流图](#534-根据线性代码建立控制流图)
- [5.4 将值映射到名字](#54-将值映射到名字)
  - [5.4.1 临时值的命名](#541-临时值的命名)
  - [5.4.2 静态单赋值形式](#542-静态单赋值形式)
  - [5.4.3 内存模型](#543-内存模型)
- [5.5 符号表](#55-符号表)
  - [5.5.1 散列表](#551-散列表)
  - [5.5.2 建立符号表](#552-建立符号表)
  - [5.5.3 处理嵌套的作用域](#553-处理嵌套的作用域)
  - [5.5.4 符号表的许多用途](#554-符号表的许多用途)
  - [5.5.5 符号表技术的其他用途](#555-符号表技术的其他用途)
- [5.6 小结和展望](#56-小结和展望)

## 5.1 简介

IR（intermediate representation）是编译器的中间表示。编译器可能有唯一的 IR，也可能在将代码从源语言转换为目标语言的的过程中使用一些列的 IR。

### 5.1.1 中间表示的分类

IR 从结构上分类：

- 图 IR
- 线性 IR
- 混合 IR

## 5.2 图IR

### 5.2.1 与语法相关的树

- 语法分析树（Parse Tree）
- 抽象语法树（Abstract Syntax Tree, AST）
- 有向非循环图（Directed Acyclic Graph, DAG）
- 抽象层次（Level of Abstraction）

### 5.2.2 图

- 控制流图（Control-Flow Graph, CFG），是一个有向 G=(N,E)
  - CFG 用一个结点表示每个基本程序块，用一条边表示块间的每个可能的控制转移。
- 依赖关系图（Dependence Graph）
  - 数据依赖关系图中的节点表示操作。边连接两个结点，一个结点定义了一个值，而另一个结点使用该值。
- 调用图（Call Graph）
  - 调用图用结点表示每个过程，用一条边表示每个不同的过程调用位置。

## 5.3 线性IR

汇编语言程序是一种线性代码。它包含了一个指令序列，其中的各个指令按出现顺序执行。指令可能包含多个操作，倘若如此，这些操作是并行执行的。编译器中使用的线性 IR 类似抽象机的汇编代码。

### 5.3.1 堆栈机代码

堆栈机代码是一种单地址代码，假定操作数存在一个栈中。大多数操作从栈获得操作数，并将其结果推入栈。

### 5.3.2 三地址代码

三地址代码中，大多数操作形如`i ← j op k`，其中包括一个运算符 op，两个操作数 j 和 k，一个结果 i。

### 5.3.3 线性代码的表示

三地址代码通常实现为一组四元组。

### 5.3.4 根据线性代码建立控制流图

通常，编译器必须根据表示过程的简单线性 IR 来建立 CFG。

## 5.4 将值映射到名字

编译器用来为执行期间计算出的各种值分配内部名字的规则，也对它能够生成的代码有所影响。命名方案方案可能会揭示优化的机会，也可能使优化的机会变得模糊不清。

### 5.4.1 临时值的命名

在底层 IR 中，各个中间结果都有自身的名字。使用不同的名字会将这些结果暴露给分析和变换的过程。

### 5.4.2 静态单赋值形式

静态单赋值形式（Static Single-Assignment Form, SSA）是一种命名规范，许多现代编译器使用 SSA 将程序中控制流和数据值流动的信息编码到名字中。在静态单赋值形式中，名字唯一地对应到代码中特定地定义位置；每个名字都是通过单个操作定义地，这也是静态单赋值形式名称地来历。

程序满足两种约束则为静态单赋值形式：

- 每个定义都有一个不同地名字
- 每次使用引用一个定义

为将 IR 程序转换为静态单赋值形式，编译器需要在不同控制流路径合并的位置插入 函数，然后重命名变量，使之满足名字分派的唯一性。

- SSA：一种 IR，具有基于值的命名系统，是通过重命名和使用称为 φ 函数的伪操作产生的。
- φ 函数：获取几个名字并将其合并，以定义一个新的名字。

引入静态单赋值形式意在代码优化。

φ 函数并不符合三地址模型。φ 函数可以有任意数目的操作数。

### 5.4.3 内存模型

正如命名临时值的机制会影响到程序的 IR 版本中能够表示的信息，而编译器对每个值的存储位置的选择也有类似的影响。

一般来说，编译器会使用以下两种内存模型之一。

- 寄存器到寄存器的模型（Register-to-Register Model）
- 内存到内存的模型（Memory-to-Memory Model）

在大多数情况下，内存模型的选择与 IR 的选择是正交的。

由于两种原因，用于 RISC 机器的编译器倾向于使用寄存器到寄存器的模型。

第一，寄存器到寄存器的模型更严密地反映了 RISC 体系结构地指令集。RISC 机器上，内存到内存操作地集合是不完备的；相反，它们隐含的假定值可以保存在寄存器中。

第二，寄存器到寄存器的模型，允许编译器将其推导出的一部分微妙的事实直接编码在 IR 中。值保存在寄存器中的事实，意味着编译器已经在先前的某个位置上指明了将其保存在寄存器中是安全的。除非编译器将该事实编码到 IR 中，否则它将必须反复地证明这一点。

## 5.5 符号表

符号表的实现需要对细节的关注。因为几乎转换过程中的每个方面都会引用符号表，所以对符号表的访问效率是个关键问题。

### 5.5.1 散列表

散列表对预期情形下的查找操作提供了常数时间的访问能力。

### 5.5.2 建立符号表

- LookUp(name)
- Insert(name, record)

### 5.5.3 处理嵌套的作用域

- InitializeScope()
- FinalizeScope()

### 5.5.4 符号表的许多用途

- 结构表
  - 用于指定结构或记录中总段的文本串，存在与变量和过程不同的命名空间中。
  - 管理字段名的命名空间有几种方法：
    - 独立表
    - 选择符表
    - 统一表
- 使用链接表解决面向对象语言中的名字解析问题

### 5.5.5 符号表技术的其他用途

## 5.6 小结和展望

中间表示的选择对编译器的设计、实现、速度和有效性都有着重大影响。
