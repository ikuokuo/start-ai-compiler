# CH12 指令调度 (Instruction Scheduling)

- [12.1 简介](#121-简介)
- [12.2 指令调度问题](#122-指令调度问题)
  - [12.2.1 度量调度质量的其他方式](#1221-度量调度质量的其他方式)
  - [12.2.2 是什么使调度这样难](#1222-是什么使调度这样难)
- [12.3 局部表调度](#123-局部表调度)
  - [12.3.1 算法](#1231-算法)
  - [12.3.2 调度具有可变延迟的操作](#1232-调度具有可变延迟的操作)
  - [12.3.3 扩展算法](#1233-扩展算法)
  - [12.3.4 在表调度算法中打破平局](#1234-在表调度算法中打破平局)
  - [12.3.5 前向表调度与后向表调度](#1235-前向表调度与后向表调度)
  - [12.3.6 提高表调度的效率](#1236-提高表调度的效率)
- [12.4 区域性调度](#124-区域性调度)
  - [12.4.1 调度扩展基本程序块](#1241-调度扩展基本程序块)
  - [12.4.2 跟踪调度](#1242-跟踪调度)
  - [12.4.3 通过复制构建适当的上下文环境](#1243-通过复制构建适当的上下文环境)
- [12.5 高级主题](#125-高级主题)
  - [12.5.1 软件流水线的策略](#1251-软件流水线的策略)
  - [12.5.2 用于实现软件流水线的算法](#1252-用于实现软件流水线的算法)
- [12.6 小结和展望](#126-小结和展望)

## 12.1 简介

一组操作的执行时间严重依赖于其执行顺序。指令调度试图重排一个过程中的各个操作，以改进其运行时间。本质上，指令调度试图在每个周期执行尽可能多的操作。

指令调度的主导技术是一种贪婪启发式算法，称为表调度。

指令调度器有 3 个主要目标：

- 它必须保持输入代码的语义
- 它应该通过避免拖延或 nop 指令来最小化执行时间
- 它应该尽可能避免延长值的生命周期，至少不能因此导致额外的寄存器溢出

## 12.2 指令调度问题

指令调度问题定义在基本程序块的依赖关系图 D 上。

随调度长度的概念而来的是时间最优调度（time-optimal schedule）。

### 12.2.1 度量调度质量的其他方式

调度还可以用时间以外的其他值。

### 12.2.2 是什么使调度这样难

指令调度是 NP 完全的。实际上，编译器会使用贪婪启发式算法对调度问题生成近似解。

## 12.3 局部表调度

### 12.3.1 算法

将表调度应用到程序块，调度器遵循一个包含四个步骤的计划。

- 重命名以避免反相关
- 建立依赖关系图 D
- 为每个操作指定优先级
- 重复选择一个操作并调度它

### 12.3.2 调度具有可变延迟的操作

平衡调度（balanced scheduling）

### 12.3.3 扩展算法

### 12.3.4 在表调度算法中打破平局

良好的调度器对每个操作可能设置有两三个用于打破平衡的优先级，调度器会按照某种一致的次序应用这些优先级。

### 12.3.5 前向表调度与后向表调度

### 12.3.6 提高表调度的效率

## 12.4 区域性调度

### 12.4.1 调度扩展基本程序块

EBB

### 12.4.2 跟踪调度

跟踪调度扩展了路径调度的基本概念，使之超越了 EBB 中路径的范围。

### 12.4.3 通过复制构建适当的上下文环境

## 12.5 高级主题

### 12.5.1 软件流水线的策略

软件流水线（Software Pipelining）化的循环可以将循环中连续的各个迭代操作重叠执行。

- 循环核：软件流水线化循环的核心部分。核以交错方式执行了循环的大部分迭代。

### 12.5.2 用于实现软件流水线的算法

- 估算核的大小
- 调度核
- 生成起始代码和收尾代码

## 12.6 小结和展望

调度问题出现在许多领域，从建筑、工业生产、服务交付到为航天飞机加装载荷等。1960 年以来，指令调度就已经被作为一个独立的问题进行研究。
