# CH06 过程抽象 (The Procedure Abstraction)

- [6.1 简介](#61-简介)
- [6.2 过程调用](#62-过程调用)
- [6.3 命名空间](#63-命名空间)
  - [6.3.1 类Algol语言的命名空间](#631-类algol语言的命名空间)
  - [6.3.2 用于支持类Algol语言的运行时结构](#632-用于支持类algol语言的运行时结构)
  - [6.3.3 面向对象语言的命名空间](#633-面向对象语言的命名空间)
  - [6.3.4 支持面向对象语言的运行时结构](#634-支持面向对象语言的运行时结构)
- [6.4 过程之间值的传递](#64-过程之间值的传递)
  - [6.4.1 传递参数](#641-传递参数)
  - [6.4.2 返回值](#642-返回值)
  - [6.4.3 确定可寻址性](#643-确定可寻址性)
- [6.5 标准化链接](#65-标准化链接)
- [6.6 高级主题](#66-高级主题)
  - [6.6.1 堆的显式管理](#661-堆的显式管理)
  - [6.6.2 隐式释放](#662-隐式释放)
- [6.7 小结和展望](#67-小结和展望)

## 6.1 简介

过程是大多数现代程序设计语言中的核心抽象之一。过程建立了一个受控的执行环境，每个过程都具有自身私有的命名化存储空间（即局部变量）。过程帮助定义了系统组件之间的接口，跨组件交互通常以过程调用的形式建立。最后，过程是大多编译器工作处理的基本单元。

过程提供了三个关键抽象，使得我们能够构建重要的程序。

- 过程调用抽象
- 命名空间
- 外部接口

编译器必须规定内存的布局，并将布局的相关信息编码到生成的程序中。因为编译器必须在不同的时间编译程序的不同组件，而事先无法得知各组件彼此的关系，内存布局和所有约定都必须是标准化的，并一致地应用到各个组件上。

## 6.2 过程调用

类 Algol 语言的调用和返回行为可以利用栈模拟。

1 面向对象语言中的控制流

从过程调用和返回的视角看，面向对象语言（OOL）类似于类 Algol 语言。主要差别在于用于指定被调用者和在运行时定位被调用者的机制。

2 更复杂的控制流

追随 Scheme 的做法，许多程序设计语言允许程序将一个过程及其运行时上下文封装到一个对象中，称为闭包（Closure）。在调用闭包时，过程在封装的运行时上下文中执行。使用简单的栈不足以实现这种控制抽象。

## 6.3 命名空间

### 6.3.1 类Algol语言的命名空间

- 嵌套的词法作用域
  - 词法作用域（lexical scoping）
- 各种语言的作用域规则
  - FORTRAN, C, Scheme

### 6.3.2 用于支持类Algol语言的运行时结构

活动记录（Activation Record, AR）：一个分配的内存区，用于保存与单个过程的单词激活实例相关联的控制信息和数据存储。

活动记录指针（Activation Record Pointer, ARP）：为定位当前 AR，编译器需要设法在一个指定的寄存器中维持一个指向 AR 的指针。

- 局部存储
  - 为局部数据分配空间
  - 初始化变量
  - 用于保存寄存器值的空间
- 分配活动记录
  - 活动记录的栈分配方式
  - 活动记录的堆分配方式
  - 活动记录的静态分配
  - 合并活动记录

### 6.3.3 面向对象语言的命名空间

- 可见性
- 类层次结构中的命名
  - 封闭的类结构：编译器已固定
  - 开放的类结构：运行时可改变

### 6.3.4 支持面向对象语言的运行时结构

面向对象语言也需要运行时结构支持其词法作用域层次和类层次结构。

- 活动记录（AR, Activation Record）
- 对象记录（OR, Object Record）
  - 方法调用
  - 对象记录布局
  - 静态分派与动态分派
  - 多继承

## 6.4 过程之间值的传递

### 6.4.1 传递参数

参数绑定将调用位置处的实参映射到被调用者的形参。

- 传值调用（call-by-value）
- 传引用调用（call-by-reference）
- 参数的存储空间

### 6.4.2 返回值

为从函数返回一个值，编译器必须为返回值预留空间。

### 6.4.3 确定可寻址性

- 具有静态基地址的变量
- 具有动态基地址的变量
  - 当前过程的局部变量
  - 其他过程的局部变量
- 存取链（Access Link）：编译器确保各个 AR 都包含一个指针，称为存取链（access link）或静态链（static link），指向其词法上紧邻的祖先。
- GD（Global Display）：编译器配一个单一的全局数组，称为 display，来保存各个词法层次上最新激活的过程的 ARP。

## 6.5 标准化链接

过程的链接属性是编译器、操作系统、目标机之间的一个契约，对命名、资源分配、可寻址性和保护等职责进行了清楚的划分。

链接约定必然是与机器相关的。

每个过程都有：

- 调用前代码序列（Precall Sequence）
- 返回后代码序列（Postreturn Sequence）
- 起始代码序列（Prologue Sequence）
- 收尾代码序列（Epilogue Sequence）

链接约定：

- 保存寄存器
- 分配活动记录
- 管理 display 和存取链

## 6.6 高级主题

编译器必须安排内存空间，以保存各个运行时结构。

### 6.6.1 堆的显式管理

1 最先适配分配（First-Fit Allocation）

最先适配分配的目标是在堆中快速分配/释放空间。最先适配分配对速度的强调要甚于对内存的利用。堆中的每个内存块都有一个隐藏字段，标明了其长度。

可用于分配的内存块位于一个称为空闲链表（free list）的链表上。除了强制性的长度字段之外，空闲链表上的块还有一些额外字段。每个空闲块都有一个指针指向空闲链表上的下一个块（最后一个块的指针设置为 NULL），而块的最后一个字是一个指针，指向块本身。

2 多内存池分配器（Multipool Allocators）

现代分配器派生自最先适配分配，但利用几个有关程序行为的见解进行了简化。

- 随着内存数量的增加，如果浪费一些内存空间可以使分配操作更快速，那么这样的做法变得较为合理。
- 对程序行为的研究表明，实际的程序频繁使用少量常见的长度来分配内存，而很少指定较大的长度或不常见的长度来分配内存

现代分配器分配对几个常见的长度使用独立的内存池。通常，选定的长度都是2的幂，从较小的块长度（如16字节）开始，递增至虚拟内存页的长度（通常是4096或8192字节）。每个内存池只有一种长度的内存块，由此 allocate 只需返回对应空闲链表上的第一个块，free 只需将块添加到对应空闲链表的头部。对于分配长度大于一页的请求，将使用一个独立的最先适配分配器，基于这种思想的分配器比较快速。对利用堆分配活动记录的做法，这种分配器特别适用。

3 协助调试（Debugging Help）

使用显式的内存分配/释放机制编写的程序很难调试。看起来程序员在判断何时释放堆中分配的对象时颇有困难。如果分配器能够快速区分已分配的对象和空闲对象，那么在调试过程中堆管理软件可以向程序员提供一些帮助。

### 6.6.2 隐式释放

- 垃圾收集（garbage collection）：隐式释放运行时堆中存在的对象。

方法：

- 引用计数
- 批处理垃圾收集器
  - 标记-清除收集器、复制收集器
- 标识活动数据
- 标记-清除收集器：考察整个堆
- 复制收集器：只考察活动数据
  - 停止-复制收集器、分代收集器
- 各种技术的比较

## 6.7 小结和展望
