# CH10 标量优化 (Scalar Optimizations)

- [10.1 简介](#101-简介)
- [10.2 消除无用和不可达代码](#102-消除无用和不可达代码)
  - [10.2.1 消除无用代码](#1021-消除无用代码)
  - [10.2.2 消除无用控制流](#1022-消除无用控制流)
  - [10.2.3 消除不可达代码](#1023-消除不可达代码)
- [10.3 代码移动](#103-代码移动)
  - [10.3.1 缓式代码移动](#1031-缓式代码移动)
  - [10.3.2 代码提升](#1032-代码提升)
- [10.4 特化](#104-特化)
  - [10.4.1 尾调用优化](#1041-尾调用优化)
  - [10.4.2 叶调用优化](#1042-叶调用优化)
  - [10.4.3 参数提升](#1043-参数提升)
- [10.5 冗余消除](#105-冗余消除)
  - [10.5.1 值相同与名字相同](#1051-值相同与名字相同)
  - [10.5.2 基于支配者的值编号算法](#1052-基于支配者的值编号算法)
- [10.6 为其他变换制造时机](#106-为其他变换制造时机)
  - [10.6.1 超级块复制](#1061-超级块复制)
  - [10.6.2 过程复制](#1062-过程复制)
  - [10.6.3 循环外提](#1063-循环外提)
  - [10.6.4 重命名](#1064-重命名)
- [10.7 高级主题](#107-高级主题)
  - [10.7.1 合并优化](#1071-合并优化)
  - [10.7.2 强度削减](#1072-强度削减)
  - [10.7.3 选择一种优化序列](#1073-选择一种优化序列)
- [10.8 小结和展望](#108-小结和展望)

## 10.1 简介

标量优化（scalar optimization），专注于单个控制线程的代码改进技术。

## 10.2 消除无用和不可达代码

### 10.2.1 消除无用代码

Dead 由两趟组成：

- 第一趟称为 Mark，负责发现有用操作的集合
- 第二趟称为 Sweep，负责删除无用操作

控制依赖性（control dependence）的定义依赖于后向支配性（postdominance）。

### 10.2.2 消除无用控制流

Clean 直接运行在过程的 CFG 上，

- 合并冗余分支指令
- 删除空程序块
- 合并程序块
- 提升分支指令

### 10.2.3 消除不可达代码

## 10.3 代码移动

### 10.3.1 缓式代码移动

缓式代码移动（Lazy Code Motion, LCM）使用数据流分析来发现代码移动的候选操作以及放置这些操作的适当目标位置。该算法运行在程序的 IR 形式及其 CFG 上，而非在 SSA 上。

LCM 将代码移动与冗余和部分冗余计算的消除结合起来。

通过使循环中不变的计算成为冗余的并消除之，LCM 将其从循环移出，这种优化在独立进行时称为循环不变量代码移动（loop-invariant code motion）。

- 代码形式
- 可用表达式
- 可预测表达式
- 最早放置
- 延迟放置
- 重写代码

LCM 移动的是表达式求值，而非赋值操作。

### 10.3.2 代码提升

代码移动技术还可以用于减少编译后代码的长度。代码提升（Code Hoisting）的变换提供了达到该目标的一种直接方法。

## 10.4 特化

### 10.4.1 尾调用优化

尾调用（tail call）是过程的最后一个调用。

尾调用优化避免了保持和恢复 p 的状态并消除了该调用的大部分开销。

### 10.4.2 叶调用优化

不进行调用的过程称为叶过程，这种过程为特化创造了时机。

在叶过程中，寄存器分配应该设法优先使用由调用者保存的寄存器，而后才轮到由被调用者保存的寄存器。

### 10.4.3 参数提升

具有歧义的内存引用会妨碍编译器将值保存在寄存器中。有时候，编译器可用通过特例分析或对指针值/数组下标值的详细分析，来证明某个歧义值只有一个对应的内存位置。在这种情况下，编译器可以重写代码，将该值移动到一个标量局部变量中，而寄存器分配器可以将局部变量维持在寄存器中。此类变换通常称为提升（promotion）。

## 10.5 冗余消除

LVN, SVN, LCM

### 10.5.1 值相同与名字相同

### 10.5.2 基于支配者的值编号算法

基于支配者的值编号技术（Dominator-based Value Numbering Technique, DVNT）

- 处理 B 中的 φ 函数
- 处理 B 中的赋值
- 将信息传播到 B 的后继结点

## 10.6 为其他变换制造时机

### 10.6.1 超级块复制

超级块复制（Superblock Cloning）

- 它可以产生更长的程序块
- 它消除了分支
- 它在代码中产生了一些可供进一步优化的位置

### 10.6.2 过程复制

过程复制（Procedure Cloning）

### 10.6.3 循环外提

循环外提（Loop Unswitching）将循环中不变的控制流提升到循环之外。

### 10.6.4 重命名

重命名（Renaming）

## 10.7 高级主题

### 10.7.1 合并优化

稀疏条件常量传播（Sparse Conditional Constant Propagation, SCCP）的威力主要来源于常量传播和可达性两种分析之间的相互作用。

### 10.7.2 强度削减

经典例子：将基于循环索引的整数乘法替换为等价的加法。

运算符强度削减（Operation Strength Reduction, OSR)：

- 背景
  - 区域常量、归纳变量
- 算法
- 重写代码
- 返回到例子
- 线性函数判断替代（Linear-Function Test Replacement, LFTR）

### 10.7.3 选择一种优化序列

编译器在搜索好的变换序列时，将采用启发式技术对搜索空间的较小部分进行抽样。通常，这些技术分为三类：

- 改编遗传算法，使之充当某种形式的智能搜索
- 随机化搜索算法
- 统计机器学习技术

## 10.8 小结和展望
